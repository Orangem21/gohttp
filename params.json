{
  "name": "Gohttp",
  "tagline": "A simple to use golang http client",
  "body": "# gohttp\r\n[![Travis-ci Status](https://travis-ci.org/cizixs/gohttp.svg?branch=master)](https://travis-ci.org/cizixs/gohttp)\r\n[![Coverage Status](https://coveralls.io/repos/github/cizixs/gohttp/badge.svg?branch=master)](https://coveralls.io/github/cizixs/gohttp?branch=master)\r\n[![Software License](https://img.shields.io/badge/license-MIT-brightgreen.svg?style=flat-square)](LICENSE.md)\r\n[![Go Report Card](https://goreportcard.com/badge/github.com/cizixs/gohttp)](https://goreportcard.com/report/github.com/cizixs/gohttp)\r\n[![GoDoc](https://godoc.org/github.com/cizixs/gohttp?status.svg)](https://godoc.org/github.com/cizixs/gohttp)\r\n\r\nA simple to use golang http client\r\n\r\n## Features\r\n\r\n- [x] All HTTP methods support: GET/HEAD/POST/PUT/PATCH/DELETE/OPTIONS\r\n- [x] Easy to set HTTP Headers\r\n- [x] Query strings can be added through key-value pairs or struct easily\r\n- [x] Extend url path whenever you want\r\n- [x] Send form and json data in one line\r\n- [x] Basic Auth right away\r\n- [x] Read from response the easy way\r\n- [x] Support proxy configuration\r\n- [x] Allow set timeout at all levels\r\n- [ ] Automatically retry request, if you let it\r\n- [ ] Custom redirect policy\r\n- [ ] Perform hook functions\r\n- [ ] Session support, persistent response data, and reuse them in next request\r\n- More to come ...\r\n\r\n## Principles\r\n\r\n- Simple: the exposed interface should be simple and intuitive. After all, this is why `gohttp` is created\r\n- Consistent: Derived from `net/http`, `gohttp` tries to keep consistent with it as much as possible\r\n- Fully-Documented: along with the simple interface, documents and examples will be given to demostrate the full usage, pitfalls and best practices\r\n\r\n## Install\r\n\r\n```bash\r\ngo get github.com/cizixs/gohttp\r\n```\r\n\r\nAnd then import the package in your code:\r\n\r\n```go\r\nimport \"github.com/cizixs/gohttp\"\r\n```\r\n\r\n## Usage\r\n\r\n### Get a resource from url\r\n\r\n`gohttp` provides shortcut to make simple `GET` quite straightforward:\r\n\r\n    resp, err := gohttp.Get(\"https://api.github.com/users/cizixs\")\r\n\r\nThe above does the same thing as:\r\n\r\n    resp, err := gohttp.New().Get(\"https://api.github.com/users/cizixs\")\r\n\r\nIn fact, this is exactly what it does behind the scene. \r\n`gohttp.New()` returns `gohttp.Client` struct, which gives you full control of the request which be sent.\r\n\r\n### Create url path on the fly\r\n\r\nIf url path can not decided until runtime or you want it be flexible, `Path()` method is here to help:\r\n\r\n    resp, err := gohttp.New().Path(\"/repos\").Path(\"cizixs/gohttp/\").Path(\"issues\").Get(\"https://api.github.com/\")\r\n\r\nOr simply in one method:\r\n\r\n    resp, err := gohttp.New().Path(\"/repos\", \"cizixs/gohttp/\", \"issues\").Get(\"https://api.github.com/\")\r\n\r\nNotice how `gohttp` handles the slash `/` appropriately no matter where it is placed(or not placed at all).\r\n\r\n### Pass arguments(query string) in URLs \r\n\r\nThere are often times you want to include query strings in url, handling this issue manually can be tiresome and boring.\r\nNot with `gohttp`:\r\n\r\n    gohttp.New().Path(\"/repos\", \"cizixs/gohttp/\", \"issues\").\r\n        Query(\"state\", \"open\").Query(\"sort\", \"updated\").Query(\"mentioned\", \"cizixs\").\r\n        Get(\"https://api.github.com/\")\r\n\r\nThink this is tedious too? Here comes the better part, you can pass a struct as query strings:\r\n\r\n    type issueOption struct {\r\n    \tState     string `json:\"state,omitempty\"`\r\n    \tAssignee  string `json:\"assignee,omitempty\"`\r\n    \tCreator   string `json:\"creator,omitempty\"`\r\n    \tMentioned string `json:\"mentioned,omitempty\"`\r\n    \tLabels    string `json:\"labels,omitempty\"`\r\n    \tSort      string `json:\"sort,omitempty\"`\r\n    \tRirection string `json:\"direction,omitempty\"`\r\n    \tSince     string `json:\"since,omitempty\"`\r\n    }\r\n\r\n\ti := &issueOption{\r\n\t\tState:     \"open\",\r\n\t\tMentioned: \"cizixs\",\r\n\t\tSort:      \"updated\",\r\n\t}\r\n\tresp, err := gohttp.New().Path(\"/repos\", \"cizixs/gohttp/\", \"issues\").QueryStruct(i).Get(\"https://api.github.com/\")\r\n    \r\n### Custom Headers\r\n\r\n    gohttp.New().Header(key, value).Header(key, value).Get(url)\r\n\r\nOr, simply pass all headers in a map:\r\n\r\n    gohttp.New().Headers(map[string]string).Get(url)\r\n\r\n### Post and PUT\r\n\r\nNot only `GET` is simple, `gohttp` implements all other methods:\r\n\r\n    body := strings.NewReader(\"hello, gohttp!\")\r\n    gohttp.New().Body(body).Post(\"https://httpbin.org/post\")\r\n    gohttp.New().Body(body).Put(\"https://httpbin.org/put\")\r\n\r\n**NOTE**: The actual data sent is based on HTTP method the request finally fires.\r\nAnything not compliant with that METHOD will be ommited.\r\nFor example, set data to a `GET` request has no effect, because it will not be used at all.\r\n\r\n### Post all kinds of data\r\n\r\nWhen comes to sending data to server, `POST` might be the most frequently used method.\r\nOf all user cases, send form data and send json data comes to the top. \r\n`gohttp` tries to make these actions easy:\r\n\r\n    // send Form data\r\n    gohttp.New().Form(\"username\", \"cizixs\").Form(\"password\", \"secret\").Post(\"https://somesite.com/login\")\r\n\r\n    // send json data\r\n    gohttp.New().Json(`{\"Name\":\"Cizixs\"}`).Post(url)         // use a marshalled json string\r\n\r\n    struct User{\r\n        Name string `json:\"name,omitempty\"`\r\n        Age int `json:\"age,omitempty\"`\r\n    }\r\n\r\n    user := &User{Name: \"cizixs\", Age: 22}\r\n    gohttp.New().JsonStruct(user).Post(url)   // use a struct and parse it to json\r\n\r\n### Basic Auth\r\n\r\n```go\r\ngohttp.New().BasicAuth(\"username\", \"password\").Get(\"https://api.github.com/users/\")\r\n```\r\n\r\n### Timeout\r\n\r\nBy default, `net/http` does not have timeout, will wait forever until response is returned.\r\nThis can be a serious issue if server hangs, `gohttp` allows you to set a timeout limit,\r\nif response does not finish in time, an error will be returned.\r\n\r\n    gohttp.New().Timeout(100*time.Millisecond).Get()\r\n\r\n### Upload file(s)\r\n\r\nUpload files is simple too, multiple files can be uploaded in one request.\r\n\r\n    f, _ := os.Open(filePath)\r\n    gohttp.New().File(f io.Reader, \"filename\", \"fieldname\").Post(url)\r\n\r\n### Proxy\r\n\r\nIf you are sending request behind a proxy, you can do this:\r\n\r\n    gohttp.New().Proxy(\"http://127.0.0.1:4567\").Get(\"http://target.com/cool\")\r\n\r\n### Cookies\r\n\r\nAccess cookie from response is simple:\r\n\r\n    cookies := resp.Cookies()\r\n\r\n    gohttp.New().Cookie(cookie *http.Cookie).Cookie(cookie *http.Cookie).Get(url)\r\n\r\n### Response data as string\r\n\r\nIf the response contains string data, you can read it by:\r\n\r\n    resp, _ := gohttp.New().Get(\"http://someurl.com\")\r\n    data, _ := resp.AsString()\r\n\r\n\r\n### Response data as bytes\r\n\r\nIf the response contains raw bytes, you can read it by:\r\n\r\n    resp, _ := gohttp.New().Get(\"http://someurl.com\")\r\n    data, _ := resp.AsBytes()\r\n\r\n### Response data as json struct\r\n\r\nIf the response contains json struct, you can pass a struct to it, and `gohttp` will marshall it for you:\r\n\r\n    user := &User{}\r\n    resp, _ := gohttp.New().Get(\"http://someurl.com\")\r\n    err := resp.AsJSON(user)\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}